package com.erha.ops.controller;

import org.springframework.security.access.prepost.PreAuthorize;

import com.erha.ops.entity.Job;
import com.erha.ops.entity.Client;
import com.erha.ops.rfq.entity.RFQ;
import com.erha.ops.entity.Quote;
import com.erha.ops.entity.WorkProgress;
import com.erha.ops.service.JobService;
import com.erha.ops.repository.JobRepository;
import com.erha.ops.repository.JobTaskRepository;
import com.erha.ops.entity.JobTask;
import com.erha.ops.rfq.repository.RFQRepository;
import com.erha.ops.repository.QuoteRepository;
import com.erha.ops.repository.ClientRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import com.erha.ops.service.JobPdfService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;

@PreAuthorize("isAuthenticated()")
@RestController
@RequestMapping("/api/v1/jobs")
@CrossOrigin(origins = "*")
public class JobController {

    private static final Logger logger = LoggerFactory.getLogger(JobController.class);

    @Autowired
    private JobService jobService;

    @Autowired
    private JobPdfService jobPdfService;

    @Autowired
    private JobRepository jobRepository;

    @Autowired
    private JobTaskRepository jobTaskRepository;

    @Autowired
    private RFQRepository rfqRepository;

    @Autowired
    private QuoteRepository quoteRepository;

    @Autowired
    private ClientRepository clientRepository;

    // ========================================
    // BASIC CRUD OPERATIONS
    // ========================================

    @GetMapping
    public ResponseEntity<List<Job>> getAllJobs() {
        logger.info("Fetching all jobs");
        try {
            List<Job> jobs = jobService.getAllJobs();
            logger.info("Found {} jobs", jobs.size());
            return ResponseEntity.ok(jobs);
        } catch (Exception e) {
            logger.error("Error fetching jobs: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping
    public ResponseEntity<Job> createJob(@RequestBody Job job) {
        logger.info("Creating new job: {}", job.getJobNumber());
        try {
            Job createdJob = jobService.createJob(job);
            logger.info("Ã¢Å“â€œ Created job: {} - {}", createdJob.getJobNumber(), createdJob.getDescription());
            return ResponseEntity.status(HttpStatus.CREATED).body(createdJob);
        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error creating job: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // CREATE JOB FROM RFQ - AUTO-POPULATE
    // ========================================

    @PostMapping("/from-rfq/{rfqId}")
    public ResponseEntity<Map<String, Object>> createJobFromRfq(@PathVariable Long rfqId) {
        logger.info("Creating job from RFQ ID: {}", rfqId);

        try {
            // 1. Get RFQ
            Optional<RFQ> rfqOpt = rfqRepository.findById(rfqId);
            if (!rfqOpt.isPresent()) {
                logger.warn("RFQ not found with ID: {}", rfqId);
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(Map.of("error", "RFQ not found"));
            }
            RFQ rfq = rfqOpt.get();

            // 2. Check if job already exists for this RFQ
            List<Job> existingJobs = jobRepository.findByRfqId(rfqId);
            if (!existingJobs.isEmpty()) {
                Job existingJob = existingJobs.get(0);
                logger.warn("Job already exists for RFQ {}: Job ID {}", rfqId, existingJob.getJobId());
                Map<String, Object> response = new HashMap<>();
                response.put("error", "Job already exists for this RFQ");
                response.put("jobId", existingJob.getJobId());
                response.put("jobNumber", existingJob.getJobNumber());
                return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
            }

            // 3. Get Quote (if exists)
            List<Quote> quotes = quoteRepository.findByRfqId(rfqId);
            Quote quote = quotes.isEmpty() ? null : quotes.get(0);

            // 4. Get Client details (optional)
            Client client = null;
            if (rfq.getClientId() != null) {
                client = clientRepository.findById(rfq.getClientId()).orElse(null);
            }

            // 5. Create new Job with auto-populated data
            Job job = new Job();

            // Auto-generate job number (e.g., 24-XXX format)
            String jobNumber = generateJobNumber();
            job.setJobNumber(jobNumber);
            logger.info("Generated job number: {}", jobNumber);

            // From RFQ
            job.setRfqId(rfqId);
            job.setClientId(rfq.getClientId());
            job.setDescription(rfq.getDescription());
            job.setOrderNumber(rfq.getOrderNumber());
            job.setOrderReceivedDate(rfq.getOrderDate());
            job.setDepartment(rfq.getOperatingEntity()); // ERHA FC or ERHA SS

            // Location - default to SHOP
            job.setLocation(Job.JobLocation.SHOP);

            // From Quote (if exists)
            if (quote != null) {
                job.setQuoteId(quote.getQuoteId());
                job.setOrderValueExcl(quote.getValueExclVat());
                job.setOrderValueIncl(quote.getValueInclVat());
                logger.info("Linked to Quote {}: Excl={}, Incl={}",
                        quote.getQuoteId(), quote.getValueExclVat(), quote.getValueInclVat());
            } else {
                // Fall back to estimated value from RFQ
                job.setOrderValueExcl(rfq.getEstimatedValue());
                if (rfq.getEstimatedValue() != null) {
                    job.setOrderValueIncl(rfq.getEstimatedValue().multiply(new BigDecimal("1.15"))); // Add 15% VAT
                }
                logger.info("No quote found - using RFQ estimated value: {}", rfq.getEstimatedValue());
            }

            // Set dates
            job.setOrderReceivedDate(rfq.getOrderDate() != null ? rfq.getOrderDate() : LocalDate.now());

            // Calculate expected delivery (use required date or 30 days from now)
            if (rfq.getRequiredDate() != null) {
                job.setExpectedDeliveryDate(rfq.getRequiredDate());
            } else {
                job.setExpectedDeliveryDate(LocalDate.now().plusDays(30));
            }

            // Set initial status and priority based on RFQ priority
            job.setStatus(Job.JobStatus.NEW);

            String rfqPriority = rfq.getPriority().toString();
            if ("URGENT".equalsIgnoreCase(rfqPriority)) {
                job.setPriority(Job.JobPriority.URGENT);
            } else if ("HIGH".equalsIgnoreCase(rfqPriority)) {
                job.setPriority(Job.JobPriority.HIGH);
            } else if ("LOW".equalsIgnoreCase(rfqPriority)) {
                job.setPriority(Job.JobPriority.LOW);
            } else {
                job.setPriority(Job.JobPriority.MEDIUM);
            }

            // Set job type
            job.setJobType(Job.JobType.NORMAL);

            // Initialize progress tracking
            job.setProgressPercentage(0);

            // Set creation metadata
            job.setCreatedBy("SYSTEM");
            job.setCreatedDate(LocalDateTime.now());
            job.setLastModifiedBy("SYSTEM");
            job.setLastModifiedDate(LocalDateTime.now());

            // 6. Save job
            Job savedJob = jobRepository.save(job);
            logger.info("Ã¢Å“â€œ Saved job to database: ID={}", savedJob.getJobId());

            // Note: RFQ doesn't track jobId - job tracks rfqId (one-way relationship)

            // 7. Return success response
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("jobId", savedJob.getJobId());
            response.put("jobNumber", savedJob.getJobNumber());
            response.put("message", "Job created successfully from RFQ");
            response.put("rfqNumber", rfq.getJobNo());

            logger.info("Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ SUCCESS: Created job {} from RFQ {}", savedJob.getJobNumber(), rfq.getJobNo());

            return ResponseEntity.status(HttpStatus.CREATED).body(response);

        } catch (Exception e) {
            logger.error("Ã¢Å“â€”Ã¢Å“â€”Ã¢Å“â€” ERROR creating job from RFQ: {}", e.getMessage(), e);
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "Failed to create job: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    /**
     * Helper method to generate job number in format YY-NNN
     * Example: 24-745, 25-001
     */
    private String generateJobNumber() {
        // Get current year (last 2 digits)
        int year = LocalDate.now().getYear() % 100;
        String yearPrefix = String.format("%02d-", year);

        // Get all jobs and filter by year prefix
        List<Job> allJobs = jobRepository.findAll();
        List<Job> jobsThisYear = allJobs.stream()
                .filter(j -> j.getJobNumber() != null && j.getJobNumber().startsWith(yearPrefix))
                .collect(java.util.stream.Collectors.toList());

        int nextNumber = 1;
        if (!jobsThisYear.isEmpty()) {
            // Extract highest number
            Optional<Integer> maxNumber = jobsThisYear.stream()
                    .map(j -> {
                        try {
                            String[] parts = j.getJobNumber().split("-");
                            if (parts.length >= 2) {
                                return Integer.parseInt(parts[1]);
                            }
                            return 0;
                        } catch (Exception e) {
                            logger.warn("Could not parse job number: {}", j.getJobNumber());
                            return 0;
                        }
                    })
                    .max(Integer::compareTo);

            nextNumber = maxNumber.orElse(0) + 1;
        }

        // Format: 24-745 (YY-NNN)
        String jobNumber = String.format("%02d-%d", year, nextNumber);
        logger.info("Generated job number: {} (year={}, sequence={})", jobNumber, year, nextNumber);
        return jobNumber;
    }

    @GetMapping("/{id}")
    public ResponseEntity<Job> getJobById(@PathVariable Long id) {
        logger.info("Fetching job by ID: {}", id);
        try {
            Optional<Job> job = jobService.getJobById(id);
            if (job.isPresent()) {
                logger.info("Found job: {}", job.get().getJobNumber());
                return ResponseEntity.ok(job.get());
            } else {
                logger.warn("Job not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            logger.error("Error fetching job: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<Job> updateJob(@PathVariable Long id, @RequestBody Job job) {
        logger.info("Updating job with ID: {}", id);
        try {
            Job updatedJob = jobService.updateJob(id, job);
            logger.info("Ã¢Å“â€œ Updated job: {}", updatedJob.getJobNumber());
            return ResponseEntity.ok(updatedJob);
        } catch (RuntimeException e) {
            logger.warn("Job not found with ID: {}", id);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error updating job: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, Object>> deleteJob(@PathVariable Long id) {
        logger.info("Deleting job with ID: {}", id);
        try {
            Optional<Job> job = jobService.getJobById(id);
            if (job.isEmpty()) {
                logger.warn("Job not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }

            jobService.deleteJob(id);
            logger.info("Ã¢Å“â€œ Deleted job: {}", job.get().getJobNumber());

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("message", "Job deleted successfully");
            response.put("jobId", id);
            response.put("jobNumber", job.get().getJobNumber());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error deleting job: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // PATCH - Full partial update
    @PatchMapping("/{id}")
    public ResponseEntity<Job> partialUpdateJob(@PathVariable Long id, @RequestBody Map<String, Object> updates) {
        logger.info("Partial update job with ID: {} - Fields: {}", id, updates.keySet());

        try {
            Optional<Job> existingJob = jobService.getJobById(id);

            if (existingJob.isEmpty()) {
                logger.warn("Job not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }

            Job job = existingJob.get();

            // Update only provided fields
            if (updates.containsKey("jobNumber")) {
                job.setJobNumber((String) updates.get("jobNumber"));
            }
            if (updates.containsKey("description")) {
                job.setDescription((String) updates.get("description"));
            }
            if (updates.containsKey("department")) {
                job.setDepartment((String) updates.get("department"));
            }
            if (updates.containsKey("status")) {
                String statusStr = (String) updates.get("status");
                job.setStatus(Job.JobStatus.valueOf(statusStr.toUpperCase()));
                logger.info("Ã¢â€ â€™ Changing job {} status to: {}", job.getJobNumber(), statusStr);
            }
            if (updates.containsKey("location")) {
                String locationStr = (String) updates.get("location");
                job.setLocation(Job.JobLocation.valueOf(locationStr.toUpperCase()));
            }
            if (updates.containsKey("clientId")) {
                job.setClientId(Long.valueOf(updates.get("clientId").toString()));
            }
            if (updates.containsKey("quoteId")) {
                job.setQuoteId(Long.valueOf(updates.get("quoteId").toString()));
                logger.info("Ã¢â€ â€™ Linking job {} to quote ID: {}", job.getJobNumber(), updates.get("quoteId"));
            }
            if (updates.containsKey("rfqId")) {
                job.setRfqId(Long.valueOf(updates.get("rfqId").toString()));
            }
            if (updates.containsKey("orderNumber")) {
                job.setOrderNumber((String) updates.get("orderNumber"));
            }
            if (updates.containsKey("orderValueExcl")) {
                Object value = updates.get("orderValueExcl");
                job.setOrderValueExcl(new BigDecimal(value.toString()));
            }
            if (updates.containsKey("orderValueIncl")) {
                Object value = updates.get("orderValueIncl");
                job.setOrderValueIncl(new BigDecimal(value.toString()));
            }
            if (updates.containsKey("expectedDeliveryDate")) {
                String dateStr = (String) updates.get("expectedDeliveryDate");
                job.setExpectedDeliveryDate(LocalDate.parse(dateStr));
            }
            if (updates.containsKey("actualDeliveryDate")) {
                String dateStr = (String) updates.get("actualDeliveryDate");
                job.setActualDeliveryDate(LocalDate.parse(dateStr));
            }

            Job updatedJob = jobService.updateJob(id, job);
            logger.info("Ã¢Å“â€œ Partial update successful for job: {}", updatedJob.getJobNumber());
            return ResponseEntity.ok(updatedJob);

        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error in partial update: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // PATCH - Status only (kept for backward compatibility)
    @PatchMapping("/{id}/status")
    public ResponseEntity<Job> updateJobStatus(
            @PathVariable Long id,
            @RequestParam String status) {
        logger.info("Updating job {} status to: {}", id, status);
        try {
            Job.JobStatus jobStatus = Job.JobStatus.valueOf(status.toUpperCase());
            Job updatedJob = jobService.updateJobStatus(id, jobStatus);
            logger.info("Ã¢Å“â€œ Job {} status updated to: {}", updatedJob.getJobNumber(), status);
            return ResponseEntity.ok(updatedJob);
        } catch (IllegalArgumentException e) {
            logger.warn("Invalid status '{}': {}", status, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error updating job status: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // FILTERING & SEARCH
    // ========================================

    @GetMapping("/status/{status}")
    public ResponseEntity<List<Job>> getJobsByStatus(@PathVariable String status) {
        logger.info("Fetching jobs by status: {}", status);
        try {
            Job.JobStatus jobStatus = Job.JobStatus.valueOf(status.toUpperCase());
            List<Job> jobs = jobService.getJobsByStatus(jobStatus);
            logger.info("Found {} jobs with status {}", jobs.size(), jobStatus);
            return ResponseEntity.ok(jobs);
        } catch (IllegalArgumentException e) {
            logger.warn("Invalid status '{}': {}", status, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            logger.error("Error fetching jobs by status: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/department/{department}")
    public ResponseEntity<List<Job>> getJobsByDepartment(@PathVariable String department) {
        logger.info("Fetching jobs for department: {}", department);
        try {
            List<Job> jobs = jobService.getJobsByDepartment(department);
            logger.info("Found {} jobs for department {}", jobs.size(), department);
            return ResponseEntity.ok(jobs);
        } catch (Exception e) {
            logger.error("Error fetching jobs by department: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/client/{clientId}")
    public ResponseEntity<List<Job>> getJobsByClient(@PathVariable Long clientId) {
        logger.info("Fetching jobs for client ID: {}", clientId);
        try {
            List<Job> jobs = jobService.getJobsByClient(clientId);
            logger.info("Found {} jobs for client {}", jobs.size(), clientId);
            return ResponseEntity.ok(jobs);
        } catch (Exception e) {
            logger.error("Error fetching jobs by client: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/emergency")
    public ResponseEntity<List<Job>> getEmergencyJobs() {
        logger.info("Fetching urgent/overdue jobs");
        try {
            // Get overdue jobs as emergency jobs
            List<Job> jobs = jobService.getOverdueJobs();
            logger.info("Found {} urgent/overdue jobs", jobs.size());
            return ResponseEntity.ok(jobs);
        } catch (Exception e) {
            logger.error("Error fetching urgent jobs: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // JOB CARD GENERATION
    // ========================================

    @GetMapping("/{id}/job-card")
    public ResponseEntity<Map<String, Object>> getJobCard(@PathVariable Long id) {
        logger.info("Generating job card for job ID: {}", id);

        try {
            Optional<Job> jobOpt = jobService.getJobById(id);

            if (jobOpt.isEmpty()) {
                logger.warn("Job not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }

            Job job = jobOpt.get();

            Map<String, Object> jobCard = new HashMap<>();
            jobCard.put("jobNumber", job.getJobNumber());
            jobCard.put("description", job.getDescription());
            jobCard.put("department", job.getDepartment());
            jobCard.put("status", job.getStatus().toString());
            jobCard.put("location", job.getLocation().toString());
            jobCard.put("clientId", job.getClientId());
            jobCard.put("orderNumber", job.getOrderNumber());
            jobCard.put("orderValue", job.getOrderValueExcl());
            jobCard.put("expectedDelivery", job.getExpectedDeliveryDate());
            jobCard.put("generatedAt", LocalDate.now());

            logger.info("Ã¢Å“â€œ Generated job card for: {}", job.getJobNumber());
            return ResponseEntity.ok(jobCard);

        } catch (Exception e) {
            logger.error("Ã¢Å“â€” Error generating job card: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // PDF GENERATION
    // ========================================

    @GetMapping("/{id}/job-card-pdf")
    public ResponseEntity<byte[]> getJobCardPdf(@PathVariable Long id) {
        logger.info("Generating PDF job card for job ID: {}", id);

        try {
            Optional<Job> jobOpt = jobService.getJobById(id);

            if (jobOpt.isEmpty()) {
                logger.warn("Job not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }

            Job job = jobOpt.get();
            byte[] pdfBytes = jobPdfService.generateJobCardPdf(job);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PDF);
            headers.setContentDispositionFormData("inline", "JobCard_" + job.getJobNumber() + ".pdf");
            headers.setCacheControl("must-revalidate, post-check=0, pre-check=0");

            logger.info("PDF generated successfully for job: {}", job.getJobNumber());
            return new ResponseEntity<>(pdfBytes, headers, HttpStatus.OK);

        } catch (Exception e) {
            logger.error("Error generating PDF job card: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // STATISTICS
    // ========================================

    @GetMapping("/statistics")
    public ResponseEntity<Map<String, Object>> getJobStatistics() {
        logger.info("Fetching job statistics");
        try {
            List<Job> allJobs = jobService.getAllJobs();

            Map<String, Object> stats = new HashMap<>();
            stats.put("totalJobs", allJobs.size());
            stats.put("activeJobs", allJobs.stream().filter(j ->
                    j.getStatus() == Job.JobStatus.IN_PROGRESS ||
                            j.getStatus() == Job.JobStatus.QUALITY_CHECK ||
                            j.getStatus() == Job.JobStatus.READY
            ).count());
            stats.put("completedJobs", allJobs.stream().filter(j ->
                    j.getStatus() == Job.JobStatus.COMPLETE ||
                            j.getStatus() == Job.JobStatus.DELIVERED ||
                            j.getStatus() == Job.JobStatus.INVOICED
            ).count());
            stats.put("overdueJobs", jobService.getOverdueJobs().size());

            logger.info("Statistics: Total={}, Active={}, Completed={}, Overdue={}",
                    stats.get("totalJobs"), stats.get("activeJobs"),
                    stats.get("completedJobs"), stats.get("overdueJobs"));

            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            logger.error("Error fetching statistics: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // PARENT/CHILD JOB MANAGEMENT
    // ========================================

    /**
     /**
     * Create child jobs under a parent job (accepts array)
     * POST /api/v1/jobs/{parentId}/children
     */
    @PostMapping("/{parentId}/children")
    public ResponseEntity<List<Map<String, Object>>> createChildJobs(
            @PathVariable Long parentId,
            @RequestBody List<Job> childJobs) {  // ✅ Now accepts List!

        logger.info("Creating {} child job(s) under parent ID: {}", childJobs.size(), parentId);

        try {
            // Get parent job
            Optional<Job> parentOpt = jobService.getJobById(parentId);
            if (parentOpt.isEmpty()) {
                logger.warn("Parent job not found with ID: {}", parentId);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(List.of());
            }

            Job parent = parentOpt.get();

            // Mark parent as having children
            if (!Boolean.TRUE.equals(parent.getIsParentJob())) {
                parent.setIsParentJob(true);
                jobService.updateJob(parentId, parent);
                logger.info("Marked job {} as parent", parent.getJobNumber());
            }

            // Get current children count for sequencing
            List<Job> existingChildren = jobRepository.findByParentJobId(parentId);
            int startSequence = existingChildren.size() + 1;

            List<Map<String, Object>> responses = new ArrayList<>();

            // Process each child job
            for (int i = 0; i < childJobs.size(); i++) {
                Job childJob = childJobs.get(i);

                int sequenceNum = startSequence + i;
                String sequence = String.format("%02d", sequenceNum);

                // Generate child job number
                String childJobNumber = parent.getJobNumber() + "-" + sequence;

                // Set child job fields
                childJob.setJobNumber(childJobNumber);
                childJob.setParentJobId(parentId);
                childJob.setJobSequence(sequence);
                childJob.setIsParentJob(false);

                // Inherit from parent if not specified
                if (childJob.getClientId() == null) {
                    childJob.setClientId(parent.getClientId());
                }
                if (childJob.getDepartment() == null) {
                    childJob.setDepartment(parent.getDepartment());
                }
                if (childJob.getBillingType() == null) {
                    childJob.setBillingType(parent.getBillingType());
                }

                // Set defaults
                if (childJob.getCreationSource() == null) {
                    childJob.setCreationSource("MANUAL");
                }
                if (childJob.getStatus() == null) {
                    childJob.setStatus(Job.JobStatus.NEW);
                }
                if (childJob.getPriority() == null) {
                    childJob.setPriority(Job.JobPriority.MEDIUM);
                }

                childJob.setCreatedBy("SYSTEM");
                childJob.setCreatedDate(LocalDateTime.now());
                childJob.setLastModifiedBy("SYSTEM");
                childJob.setLastModifiedDate(LocalDateTime.now());

                // Save child job
                Job savedChild = jobRepository.save(childJob);

                logger.info("✓ Created child job {} under parent {}",
                        savedChild.getJobNumber(), parent.getJobNumber());

                Map<String, Object> response = new HashMap<>();
                response.put("success", true);
                response.put("jobId", savedChild.getJobId());
                response.put("jobNumber", savedChild.getJobNumber());
                response.put("parentJobNumber", parent.getJobNumber());
                response.put("sequence", sequence);

                responses.add(response);
            }

            return ResponseEntity.status(HttpStatus.CREATED).body(responses);

        } catch (Exception e) {
            logger.error("Error creating child jobs: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(List.of());
        }
    }
            
            // Set defaults
            if (childJob.getCreationSource() == null) {
                childJob.setCreationSource("MANUAL");
            }
            if (childJob.getStatus() == null) {
                childJob.setStatus(Job.JobStatus.NEW);
            }
            if (childJob.getPriority() == null) {
                childJob.setPriority(Job.JobPriority.MEDIUM);
            }
            
            childJob.setCreatedBy("SYSTEM");
            childJob.setCreatedDate(LocalDateTime.now());
            childJob.setLastModifiedBy("SYSTEM");
            childJob.setLastModifiedDate(LocalDateTime.now());
            
            // Save child job
            Job savedChild = jobRepository.save(childJob);
            
            logger.info("âœ“ Created child job {} under parent {}", 
                savedChild.getJobNumber(), parent.getJobNumber());
            
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("jobId", savedChild.getJobId());
            response.put("jobNumber", savedChild.getJobNumber());
            response.put("parentJobNumber", parent.getJobNumber());
            response.put("sequence", sequence);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
            
        } catch (Exception e) {
            logger.error("Error creating child job: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "Failed to create child job: " + e.getMessage()));
        }
    }

    /**
     * Get all child jobs for a parent
     * GET /api/v1/jobs/{parentId}/children
     */
    @GetMapping("/{parentId}/children")
    public ResponseEntity<List<Job>> getChildJobs(@PathVariable Long parentId) {
        logger.info("Fetching child jobs for parent ID: {}", parentId);
        
        try {
            List<Job> children = jobRepository.findByParentJobId(parentId);
            logger.info("Found {} child jobs for parent {}", children.size(), parentId);
            return ResponseEntity.ok(children);
        } catch (Exception e) {
            logger.error("Error fetching child jobs: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    // ========================================
    // TASK MANAGEMENT
    // ========================================

    /**
     * Get all tasks for a job
     * GET /api/v1/jobs/{jobId}/tasks
     */
    @GetMapping("/{jobId}/tasks")
    public ResponseEntity<List<JobTask>> getJobTasks(@PathVariable Long jobId) {
        logger.info("Fetching tasks for job ID: {}", jobId);
        
        try {
            List<JobTask> tasks = jobTaskRepository.findByJobIdOrderBySequenceNumberAsc(jobId);
            logger.info("Found {} tasks for job {}", tasks.size(), jobId);
            return ResponseEntity.ok(tasks);
        } catch (Exception e) {
            logger.error("Error fetching tasks: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Add a task to a job
     * POST /api/v1/jobs/{jobId}/tasks
     */
    @PostMapping("/{jobId}/tasks")
    public ResponseEntity<JobTask> addJobTask(
            @PathVariable Long jobId,
            @RequestBody JobTask task) {
        
        logger.info("Adding task to job ID: {}", jobId);
        
        try {
            // Verify job exists
            Optional<Job> jobOpt = jobService.getJobById(jobId);
            if (jobOpt.isEmpty()) {
                logger.warn("Job not found with ID: {}", jobId);
                return ResponseEntity.notFound().build();
            }
            
            // Auto-assign sequence number
            long taskCount = jobTaskRepository.countByJobId(jobId);
            task.setSequenceNumber((int) (taskCount + 1));
            
            task.setJobId(jobId);
            task.setCompleted(false);
            task.setCreatedDate(LocalDateTime.now());
            task.setUpdatedDate(LocalDateTime.now());
            
            JobTask savedTask = jobTaskRepository.save(task);
            logger.info("âœ“ Added task {} to job {}", savedTask.getTaskId(), jobId);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(savedTask);
            
        } catch (Exception e) {
            logger.error("Error adding task: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Update task (mark complete, etc)
     * PATCH /api/v1/jobs/{jobId}/tasks/{taskId}
     */
    @PatchMapping("/{jobId}/tasks/{taskId}")
    public ResponseEntity<JobTask> updateTask(
            @PathVariable Long jobId,
            @PathVariable Long taskId,
            @RequestBody Map<String, Object> updates) {
        
        logger.info("Updating task {} for job {}", taskId, jobId);
        
        try {
            Optional<JobTask> taskOpt = jobTaskRepository.findById(taskId);
            if (taskOpt.isEmpty()) {
                logger.warn("Task not found with ID: {}", taskId);
                return ResponseEntity.notFound().build();
            }
            
            JobTask task = taskOpt.get();
            
            // Update fields
            if (updates.containsKey("completed")) {
                boolean completed = (Boolean) updates.get("completed");
                task.setCompleted(completed);
                if (completed && task.getCompletedDate() == null) {
                    task.setCompletedDate(LocalDate.now());
                }
            }
            
            if (updates.containsKey("completedBy")) {
                task.setCompletedBy((String) updates.get("completedBy"));
            }
            
            if (updates.containsKey("description")) {
                task.setDescription((String) updates.get("description"));
            }
            
            if (updates.containsKey("assignedTo")) {
                task.setAssignedTo((String) updates.get("assignedTo"));
            }
            
            if (updates.containsKey("actualHours")) {
                task.setActualHours(new BigDecimal(updates.get("actualHours").toString()));
            }
            
            if (updates.containsKey("notes")) {
                task.setNotes((String) updates.get("notes"));
            }
            
            task.setUpdatedDate(LocalDateTime.now());
            
            JobTask savedTask = jobTaskRepository.save(task);
            logger.info("âœ“ Updated task {}", taskId);
            
            return ResponseEntity.ok(savedTask);
            
        } catch (Exception e) {
            logger.error("Error updating task: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    /**
     * Delete a task
     * DELETE /api/v1/jobs/{jobId}/tasks/{taskId}
     */
    @DeleteMapping("/{jobId}/tasks/{taskId}")
    public ResponseEntity<Map<String, Object>> deleteTask(
            @PathVariable Long jobId,
            @PathVariable Long taskId) {
        
        logger.info("Deleting task {} from job {}", taskId, jobId);
        
        try {
            Optional<JobTask> taskOpt = jobTaskRepository.findById(taskId);
            if (taskOpt.isEmpty()) {
                logger.warn("Task not found with ID: {}", taskId);
                return ResponseEntity.notFound().build();
            }
            
            jobTaskRepository.deleteById(taskId);
            logger.info("âœ“ Deleted task {}", taskId);
            
            return ResponseEntity.ok(Map.of("success", true, "message", "Task deleted"));
            
        } catch (Exception e) {
            logger.error("Error deleting task: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}